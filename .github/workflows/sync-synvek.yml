name: Synvek Code & Artifacts

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release Tag (Leave blank for latest)'
        required: false
        default: 'latest'
      asset_pattern:
        description: 'Asset name pattern (e.g., *.zip, *cuda*) - Leave blank for ALL assets'
        required: false
        default: ''
        
jobs:
  sync_code:
    runs-on: ubuntu-latest
    
    permissions:
      contents: read 

    steps:
      # 1. 设置变量
      - name: ⚙️ Set Variables and Directory
        id: vars
        run: |
          # 替换为您希望下载的仓库（owner/repo）
          echo "REPO=owner/repo" >> $GITHUB_ENV
          echo "DOWNLOAD_DIR=./downloads" >> $GITHUB_ENV
          
          # 创建下载目录
          mkdir -p ${{ env.DOWNLOAD_DIR }}
          
      # 2. 获取 Release Asset 列表的 JSON 数据
      # 关键修复：使用 --arg 传递模式，并在 Shell 中进行通配符转换
      - name:  Get Release Assets Data
        id: get_assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ github.event.inputs.tag }}
          # 将输入的通配符模式转换为 jq可用的正则表达式，例如：*.zip -> .*\\.zip
          # 注意：这里需要双重转义，因为我们将它作为Shell变量传递
          # 模式为空时，使用 .* 匹配所有文件
          REGEX_PATTERN: ${{ github.event.inputs.asset_pattern == '' && '.*' || github.event.inputs.asset_pattern | replace('*', '.*') | replace('.', '\\.') }}
        run: |
          echo "Fetching Release Assets for tag: $TAG with pattern: ${{ env.REGEX_PATTERN }}"
          
          if [ "$TAG" == "latest" ]; then
            RELEASE_JSON=$(gh api /repos/${{ env.REPO }}/releases/latest)
          else
            RELEASE_JSON=$(gh api /repos/${{ env.REPO }}/releases/tags/${TAG})
          fi
          
          # 使用 --arg 安全地将 REGEX_PATTERN 传递给 jq 变量 $regex
          # 在 jq 表达式中使用 $regex 变量进行筛选
          ASSET_DATA=$(echo "${RELEASE_JSON}" | \
            jq -r --arg regex "${{ env.REGEX_PATTERN }}" '.assets[] | 
              # 筛选逻辑：如果模式为空 (在 env 变量中被替换为 .*)，或者文件名匹配 $regex
              select(.name | test($regex)) |
              
              # 格式化输出： name | browser_download_url | digest (去除 sha256: 前缀)
              (.name + "|" + .browser_download_url + "|" + (.digest | ltrimstr("sha256:")))'
          )
          
          if [ -z "$ASSET_DATA" ]; then
              echo "::warning::No assets found matching the pattern or the release."
              exit 0 
          fi
          
          # 将包含所有资产数据的字符串存储为输出变量（处理多行问题）
          ASSET_DATA_OUTPUT=$(echo "$ASSET_DATA" | sed ':a;N;$!ba;s/\n/%NL%/g')
          echo "asset_list=$ASSET_DATA_OUTPUT" >> $GITHUB_OUTPUT

      # 3. 循环下载并校验所有文件 (此步骤无需更改，因为它依赖于步骤 2 的输出)
      - name: ⬇️ Download and Verify Assets
        env:
          ASSET_LIST: ${{ steps.get_assets.outputs.asset_list }}
          DOWNLOAD_DIR: ${{ env.DOWNLOAD_DIR }}
        run: |
          if [ -z "$ASSET_LIST" ]; then
            echo "No assets to download."
            exit 0
          fi
          
          # 将特殊字符 %NL% 替换回换行符，并使用 while 循环处理每一行数据
          echo "$ASSET_LIST" | sed 's/%NL%/\n/g' | while IFS="|" read -r ASSET_NAME DOWNLOAD_URL SHA256_DIGEST; do
              
              if [ -z "$ASSET_NAME" ]; then
                  continue
              fi
              
              LOCAL_PATH="$DOWNLOAD_DIR/$ASSET_NAME"
              
              echo "---"
              echo "Processing: $ASSET_NAME"
              echo "Expected SHA256: $SHA256_DIGEST"
              
              # 下载文件
              curl -L -sS "$DOWNLOAD_URL" -o "$LOCAL_PATH"
              
              # 格式化校验字符串：<SHA256>  <文件路径> (注意双空格)
              VERIFY_STRING="${SHA256_DIGEST}  ${LOCAL_PATH}"
              
              echo "Verifying SHA256 checksum..."
              
              # 使用 shasum -a 256 --check - 校验文件
              echo "$VERIFY_STRING" | shasum -a 256 --check -
              
              echo "✅ $ASSET_NAME verification successful!"
          done
          echo "---"
          echo "✅ All required assets downloaded and verified."